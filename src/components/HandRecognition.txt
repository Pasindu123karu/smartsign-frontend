import React, { useRef, useEffect, useState } from "react";
import * as tf from "@tensorflow/tfjs";
import * as handpose from "@tensorflow-models/handpose";
import * as knnClassifier from "@tensorflow-models/knn-classifier";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";

const letters = Array.from({ length: 26 }, (_, i) =>
  String.fromCharCode(65 + i)
); // A-Z
const numbers = Array.from({ length: 10 }, (_, i) => i.toString()); // 0-9
const practiceKeys = [...letters, ...numbers]; // A-Z + 0-9

const classifier = knnClassifier.create();
let model: handpose.HandPose | null = null;

// floating sparkles ✨ 🌟 ⭐ 💫 🎀 🎈 🌈
const sparkles = ["✨", "🌟", "⭐", "💫", "🎀", "🎈", "🌈"];

const HandRecognition: React.FC = () => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  const [modelLoaded, setModelLoaded] = useState(false);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [detectedKey, setDetectedKey] = useState<string | null>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);

  const targetKey = practiceKeys[currentIndex];

  // =====================
  // Load saved KNN dataset
  // =====================
  const loadKNNDataset = () => {
    const dataset = localStorage.getItem("knnDataset");
    if (dataset) {
      const tensorObj = JSON.parse(dataset);
      const tensorData: any = {};
      Object.keys(tensorObj).forEach((key) => {
        tensorData[key] = tf.tensor(tensorObj[key].data, tensorObj[key].shape);
      });
      classifier.setClassifierDataset(tensorData);
      toast.success("🎉 Training data loaded!");
    }
  };

  // =====================
  // Setup model and camera
  // =====================
  const setupModel = async () => {
    try {
      model = await handpose.load();
      setModelLoaded(true);
      toast.success("🤖 Hand model ready!");
      await setupCamera();
      requestAnimationFrame(drawLoop);
    } catch (err) {
      console.error(err);
      toast.error("⚠️ Could not load model");
    }
  };

  const setupCamera = async () => {
    const video = videoRef.current;
    if (!video) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;
      await new Promise((resolve) => {
        video.onloadedmetadata = () => {
          video.play();
          resolve(true);
        };
      });
    } catch (err) {
      console.error(err);
      toast.error("⚠️ Please allow camera access");
    }
  };

  // =====================
  // Capture hand landmarks
  // =====================
  const captureHandLandmarks = async () => {
    const video = videoRef.current;
    if (!model || !video) return null;
    const predictions = await model.estimateHands(video);
    if (predictions.length > 0) {
      const landmarks = predictions[0].landmarks.flat();
      return { tensor: tf.tensor([landmarks]), hand: predictions[0] };
    }
    return null;
  };

  // =====================
  // Add training example
  // =====================
  const addTrainingExample = async (label: string) => {
    const result = await captureHandLandmarks();
    if (result) {
      classifier.addExample(result.tensor, label);
      toast.success(`⭐ Saved example for "${label}"`);

      const dataset = classifier.getClassifierDataset();
      const datasetObj: any = {};
      Object.keys(dataset).forEach((key) => {
        datasetObj[key] = {
          data: Array.from(dataset[key].dataSync()),
          shape: dataset[key].shape,
        };
      });
      localStorage.setItem("knnDataset", JSON.stringify(datasetObj));
    } else {
      toast.error("🙋 No hand found, try again!");
    }
  };

  // =====================
  // Predict current key
  // =====================
  const predictKey = async () => {
    if (!modelLoaded || classifier.getNumClasses() === 0) return;
    setIsAnalyzing(true);
    const result = await captureHandLandmarks();
    if (result && classifier.getNumClasses() > 0) {
      const prediction = await classifier.predictClass(result.tensor);
      setDetectedKey(prediction.label);

      if (prediction.label === targetKey) {
        toast.success(`🎉 Great job! You signed '${targetKey}'!`);
        setTimeout(() => {
          setCurrentIndex((prev) => (prev + 1) % practiceKeys.length);
          setDetectedKey(null);
        }, 2000);
      } else {
        toast.error(`😅 That was '${prediction.label}', try again!`);
      }
    } else {
      toast.error("🙋 Hand not detected!");
    }
    setIsAnalyzing(false);
  };

  // =====================
  // Draw hand landmarks
  // =====================
  const drawLoop = async () => {
    const canvas = canvasRef.current;
    const video = videoRef.current;
    if (!canvas || !video) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (model) {
      const predictions = await model.estimateHands(video);
      predictions.forEach((hand) => {
        const xs = hand.landmarks.map((l) => l[0]);
        const ys = hand.landmarks.map((l) => l[1]);
        ctx.strokeStyle = "#15ff00ff";
        ctx.lineWidth = 5;
        ctx.strokeRect(
          Math.min(...xs),
          Math.min(...ys),
          Math.max(...xs) - Math.min(...xs),
          Math.max(...ys) - Math.min(...ys)
        );
        hand.landmarks.forEach(([x, y]) => {
          ctx.fillStyle = "red";
          ctx.beginPath();
          ctx.arc(x, y, 6, 0, 2 * Math.PI);
          ctx.fill();
        });
      });
    }

    requestAnimationFrame(drawLoop);
  };

  useEffect(() => {
    loadKNNDataset();
    setupModel();
  }, []);

  return (
    <div className="relative min-h-screen bg-gradient-to-b from-pink-100 via-yellow-100 to-blue-100 flex flex-col items-center p-8 text-gray-800">
      {/* floating sparkles */}
      {Array.from({ length: 14 }).map((_, i) => {
        const sparkle = sparkles[i % sparkles.length];
        const left = Math.random() * 100;
        const top = Math.random() * 100;
        const delay = `${Math.random() * 3}s`;
        return (
          <div
            key={i}
            className="absolute animate-float text-xl opacity-70"
            style={{ left: `${left}%`, top: `${top}%`, animationDelay: delay }}
          >
            {sparkle}
          </div>
        );
      })}

      <h1 className="text-5xl font-extrabold text-purple-700 mb-6 drop-shadow-lg">
        🖐️ Smart Sign Trainer
      </h1>

      {/* Target key bubble */}
      <div className="w-28 h-28 flex items-center justify-center rounded-full bg-gradient-to-tr from-pink-500 via-yellow-400 to-green-400 text-white text-5xl font-bold shadow-lg">
        {targetKey}
      </div>
      <p className="text-lg font-semibold text-center mt-4">
        Try making{" "}
        <span className="font-extrabold text-purple-600">{targetKey}</span> with
        your hand!
      </p>

      {/* Video + Canvas */}
      <div className="relative shadow-2xl rounded-2xl overflow-hidden border-4 border-purple-400 mt-6">
        <video
          ref={videoRef}
          autoPlay
          playsInline
          muted
          className="w-[400px] h-[300px] rounded-2xl"
        />
        <canvas
          ref={canvasRef}
          className="absolute top-0 left-0 w-[400px] h-[300px] pointer-events-none"
        />
      </div>

      {/* Training buttons grid */}
      <div className="w-full mt-8">
        <h2 className="text-xl font-bold text-purple-600 mb-3 text-center">
          Train Letters & Numbers
        </h2>
        <div className="grid grid-cols-10 gap-2 justify-center">
          {practiceKeys.map((key) => (
            <Button
              key={key}
              onClick={() => addTrainingExample(key)}
              className="w-10 h-10 rounded-full text-sm font-bold text-white shadow-lg bg-gradient-to-br from-purple-700 to-indigo-500 hover:from-pink-500 hover:to-yellow-400 transition-all"
            >
              {key}
            </Button>
          ))}
        </div>
      </div>

      {/* Recognize Button */}
      <Button
        onClick={predictKey}
        disabled={!modelLoaded || isAnalyzing}
        className="mt-6 px-8 py-4 text-xl rounded-full shadow-lg bg-gradient-to-r from-green-500 to-blue-600 hover:from-pink-500 hover:to-purple-500 text-white font-bold"
      >
        {isAnalyzing ? "🤔 Thinking..." : "🎯 Recognize Sign"}
      </Button>

      {/* Detected Key */}
      {detectedKey && (
        <p className="mt-4 text-2xl font-bold text-pink-600">
          I saw: {detectedKey}
        </p>
      )}
    </div>
  );
};

export default HandRecognition;
